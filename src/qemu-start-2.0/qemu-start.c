/*
    kvm-start.c - Part of kvm-start, a package to start kvm nicely.
    Copyright (c) 2006  Frodo Looijaard <frodo@frodo.looijaard.name>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

#define _GNU_SOURCE /* asprintf */
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <net/if.h>
#include <linux/if_tun.h>
#include <sys/wait.h>
#include <errno.h>

/* Autogenerated by gengetopt */
#include "cmdline.h"

/* This define is present in recent glibc, it is not available on sarge */
#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 64
#endif

#define QEMU "/usr/bin/kvm"

/* Tiny code to open tap/tun device, and hand the fd to kvm.
   Run as root, drops to given user. */
int main(int argc, char *argv[])
{
	struct ifreq ifr;
	struct passwd *userdata;
	char *newargs[argc + 2];
	int fd,vlan,tapnr;
	unsigned int i;
	unsigned new_arg_count = 5;
	struct gengetopt_args_info args_info;
	char *system;
	char *topleft;

	/* Ugly fix because gengetopt 2.18 does not have the `usage' option */
	gengetopt_args_info_usage = "kvm-start [OPTIONS] -- [OPTIONS for QEMU]";

	if (cmdline_parser(argc, argv, &args_info))
		exit(1);

	/* parameter: TAPDEVNR */
	tapnr = args_info.tapnr_arg;

	/* parameter: VLAN */
	vlan = args_info.vlan_arg;

	/* parameter: System type */
	if (args_info.system_given) {
		if (index(args_info.system_arg,'/')) {
			fprintf(stderr, "Invalid value `%s' for system (may not contain a slash character)\n", args_info.system_arg);
			exit(1);
		}
		asprintf(&system, "%s", args_info.system_arg);
	}

	/* parameters: Window location */
	if (args_info.window_left_given || args_info.window_top_given) {
		if (!(args_info.window_left_given && args_info.window_top_given)) {
			fprintf(stderr,("If either window-left (x) or window-top (y) are given, then both must be given\n"));
			exit(1);
		}
		if (asprintf(&topleft, "%d,%d",args_info.window_left_arg,args_info.window_top_arg) < 0) {
			perror("Preparing top-left environment value string failed");
			exit(1);
		}
	}

	/* Open /dev/net/tun */
	fd = open("/dev/net/tun", O_RDWR);
	if (fd < 0) {
		perror("Could not open /dev/net/tun");
		exit(1);
	}

	/* Bind to the right tap device */
	memset(&ifr, 0, sizeof(ifr));
	ifr.ifr_flags = IFF_TAP | IFF_NO_PI;
	snprintf(ifr.ifr_name,IFNAMSIZ,"tap%d",tapnr);

	if (ioctl(fd, TUNSETIFF, (void *) &ifr) != 0) {
		perror("Could not get tap device");
		exit(1);
	}

	/* Get userid data. */
	userdata = getpwnam(args_info.user_arg);
	if (!userdata) {
		fprintf(stderr, "No user '%s'\n", args_info.user_arg);
		exit(1);
	}

	/* Change to QEMU user */
	if (setgroups(0, NULL)) {
		perror("setgroups failed");
		exit(1);
	}
	if (setgid(userdata->pw_gid)) {
		perror("setgid failed");
		exit(1);
	}
	if (setuid(userdata->pw_uid)) {
		perror("setuid failed");
		exit(1);
	}

	if(clearenv()) {
		perror("Clearing environment failed");
		exit(1);
	}
	if(setenv("HOME",userdata->pw_dir,1) ||
	   setenv("PATH","/usr/bin:/bin:/usr/local/bin",1) ||
	   setenv("LOGNAME",userdata->pw_name,1) ||
	   setenv("USER",userdata->pw_name,1)) {
		perror("Setting environment failed");
		exit(1);
	}

	if (args_info.window_left_given || args_info.window_top_given) {
		if (setenv("SDL_VIDEO_WINDOW_POS", topleft, 1)) {
			perror("Setting top-left environment value failed");
			exit(1);
		}
	}

	/* Create the right kvm invocation */
	if (!args_info.system_given)
		newargs[0] = QEMU;
	else if (asprintf(&newargs[0],"%s-system-%s",QEMU,args_info.system_arg) < 0) {
		perror("Preparing kvm executable filename failed");
		exit(1);
	}
	newargs[1] = "-net";
	if (asprintf(&newargs[2],"nic,vlan=%d",vlan) < 0) {
		perror("Preparing nic argument failed");
		exit(1);
	}
	if (args_info.macaddr_given) {
		if (asprintf(&newargs[2], "%s,macaddr=%s", newargs[2], args_info.macaddr_arg) < 0) {
			perror("Adding macaddress to nic argument failed");
		}
	}
	if (args_info.nic_model_given) {
		if (asprintf(&newargs[2], "%s,model=%s", newargs[2], args_info.nic_model_arg) < 0) {
			perror("Adding nic model to nic argument failed");
		}
	}
	newargs[3] = "-net";
	if (asprintf(&newargs[4],"tap,fd=%d,vlan=%d",fd,vlan) < 0) {
		perror("Preparing tap argument failed");
		exit(1);
	}
	for (i = 0; i < args_info.inputs_num; i++) {
		newargs[i+5] = args_info.inputs[i];
		new_arg_count++;
	}
	newargs[new_arg_count] = NULL;

	execvp(newargs[0], newargs);
	perror("Execution of kvm failed");
	exit(1);
}
